import Tokenizer from './src/tokenizer';
import Node from './src/ast/node';
import Tag from './src/ast/tag';
import Ast from './src/ast/index';
import * as nodes from './src/schema';
import tags from './src/tags/index';
import { truthy } from './src/tags/conditional';
import functions from './src/functions/index';
import renderers from './src/renderers/index';
import transformer from './src/transformer';
import validator from './src/validator';
import { parseTags } from './src/utils';
import transforms from './src/transforms/index';
import type Token from 'markdown-it/lib/token';
import type { Config, RenderableTreeNode, ValidateError } from './src/types';
export * from './src/types';
export declare function parse(content: string | Token[], file?: string): Node;
export declare function resolve<C extends Config = Config>(content: Node, config: C): Node;
export declare function resolve<C extends Config = Config>(content: Node[], config: C): Node[];
export declare function transform<C extends Config = Config>(node: Node, config?: C): RenderableTreeNode;
export declare function transform<C extends Config = Config>(nodes: Node[], config?: C): RenderableTreeNode[];
export declare function validate<C extends Config = Config>(content: Node, options?: C): ValidateError[];
export declare function createElement(name: string | {
    key?: string | number;
}, attributes?: {}, ...children: any[]): {
    name: string | {
        key?: string | number | undefined;
    };
    attributes: {};
    children: any[];
};
declare const _default: {
    nodes: typeof nodes;
    tags: {
        if: import("./src/types").Schema<Readonly<Partial<{
            nodes: Partial<Record<import("./src/types").NodeType, import("./src/types").Schema<Readonly<Partial<any>>, string>>>;
            tags: Record<string, import("./src/types").Schema<Readonly<Partial<any>>, string>>;
            variables: Record<string, any>;
            functions: Record<string, import("./src/types").ConfigFunction>;
            partials: Record<string, any>;
            validation?: {
                validateFunctions?: boolean | undefined;
            } | undefined;
        }>>, string>;
        else: import("./src/types").Schema<Readonly<Partial<{
            nodes: Partial<Record<import("./src/types").NodeType, import("./src/types").Schema<Readonly<Partial<any>>, string>>>;
            tags: Record<string, import("./src/types").Schema<Readonly<Partial<any>>, string>>;
            variables: Record<string, any>;
            functions: Record<string, import("./src/types").ConfigFunction>;
            partials: Record<string, any>;
            validation?: {
                validateFunctions?: boolean | undefined;
            } | undefined;
        }>>, string>;
        partial: import("./src/types").Schema<Readonly<Partial<{
            nodes: Partial<Record<import("./src/types").NodeType, import("./src/types").Schema<Readonly<Partial<any>>, string>>>;
            tags: Record<string, import("./src/types").Schema<Readonly<Partial<any>>, string>>;
            variables: Record<string, any>;
            functions: Record<string, import("./src/types").ConfigFunction>;
            partials: Record<string, any>;
            validation?: {
                validateFunctions?: boolean | undefined;
            } | undefined;
        }>>, string>;
        table: import("./src/types").Schema<Readonly<Partial<{
            nodes: Partial<Record<import("./src/types").NodeType, import("./src/types").Schema<Readonly<Partial<any>>, string>>>;
            tags: Record<string, import("./src/types").Schema<Readonly<Partial<any>>, string>>;
            variables: Record<string, any>;
            functions: Record<string, import("./src/types").ConfigFunction>;
            partials: Record<string, any>;
            validation?: {
                validateFunctions?: boolean | undefined;
            } | undefined;
        }>>, string>;
    };
    functions: {
        and: import("./src/types").ConfigFunction;
        or: import("./src/types").ConfigFunction;
        not: import("./src/types").ConfigFunction;
        equals: import("./src/types").ConfigFunction;
        default: import("./src/types").ConfigFunction;
        debug: import("./src/types").ConfigFunction;
    };
    renderers: {
        html: typeof import("./src/renderers/html").default;
        react: typeof import("./src/renderers/react/react").default;
        reactStatic: typeof import("./src/renderers/react/static").default;
    };
    transforms: typeof import("./src/transforms/table").default[];
    Ast: {
        fromJSON: (text: string) => Node | Node[];
        isAst(value?: any): value is import("./src/types").AstType;
        isFunction(value?: any): value is import("./src/ast/function").default;
        getAstValues(value: any): Generator<import("./src/types").AstType, void, unknown>;
        resolve(value: any, config?: Readonly<Partial<{
            nodes: Partial<Record<import("./src/types").NodeType, import("./src/types").Schema<Readonly<Partial<any>>, string>>>;
            tags: Record<string, import("./src/types").Schema<Readonly<Partial<any>>, string>>;
            variables: Record<string, any>;
            functions: Record<string, import("./src/types").ConfigFunction>;
            partials: Record<string, any>;
            validation?: {
                validateFunctions?: boolean | undefined;
            } | undefined;
        }>>): any;
        Function: typeof import("./src/ast/function").default;
        Node: typeof Node;
        Variable: typeof import("./src/ast/variable").default;
    };
    Tag: typeof Tag;
    Tokenizer: typeof Tokenizer;
    parseTags: typeof parseTags;
    transformer: import("./src/transformer").Transformer;
    validator: typeof validator;
    parse: typeof parse;
    transform: typeof transform;
    validate: typeof validate;
    createElement: typeof createElement;
    truthy: typeof truthy;
};
export default _default;
export { nodes, tags, functions, transforms, renderers, Ast, Tag, Tokenizer, parseTags, transformer, validator, truthy, };
//# sourceMappingURL=index.d.ts.map